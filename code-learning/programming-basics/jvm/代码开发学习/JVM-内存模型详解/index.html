<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM-内存模型详解 | Goppop的博客</title><meta name="author" content="Goppop"><meta name="copyright" content="Goppop"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM内存模型详解，深入理解堆、栈、方法区等内存区域">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM-内存模型详解">
<meta property="og:url" content="https://goppop.github.io/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Goppop的博客">
<meta property="og:description" content="JVM内存模型详解，深入理解堆、栈、方法区等内存区域">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://goppop.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-12-11T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-14T16:00:00.000Z">
<meta property="article:author" content="Goppop">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://goppop.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JVM-内存模型详解",
  "url": "https://goppop.github.io/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/",
  "image": "https://goppop.github.io/img/butterfly-icon.png",
  "datePublished": "2025-12-11T16:00:00.000Z",
  "dateModified": "2025-12-14T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Goppop",
      "url": "https://goppop.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://goppop.github.io/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM-内存模型详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="web_bg" style="background-image: url(https://images.pexels.com/photos/1200252/pexels-photo-1200252.jpeg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.pixabay.com/photo/2021/03/29/08/22/peach-flower-6133330_1280.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Goppop的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">JVM-内存模型详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">JVM-内存模型详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-11T16:00:00.000Z" title="发表于 2025-12-12 00:00:00">2025-12-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-14T16:00:00.000Z" title="更新于 2025-12-15 00:00:00">2025-12-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/code-learning/">代码开发学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/code-learning/programming-basics/">01-编程语言基础</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/code-learning/programming-basics/jvm/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="JVM-内存模型详解"><a href="#JVM-内存模型详解" class="headerlink" title="JVM-内存模型详解"></a>JVM-内存模型详解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Java 虚拟机（JVM）内存模型</strong>，更准确地说是 <strong>JVM 运行时数据区（Runtime Data Areas）</strong>，是Java虚拟机在执行Java程序过程中，将其管理的内存划分为若干个不同的数据区域。理解这些区域对于深入掌握Java程序的运行机制、内存分配、垃圾回收以及进行性能调优和故障排查至关重要 。</p>
<p>需要注意的是，<strong>JVM 运行时数据区</strong>（JVM Runtime Data Areas）与 <strong>Java 内存模型</strong>（Java Memory Model, JMM）是两个不同的概念。JVM 运行时数据区关注的是JVM如何划分和管理内存，而 JMM 则关注于在多线程环境下，变量在内存中的可见性、有序性和原子性等问题。本文档主要聚焦于前者，即 JVM 运行时数据区。</p>
<p>JVM 运行时数据区主要包含以下五个部分，它们根据是否被线程共享可以分为两大类：</p>
<table>
<thead>
<tr>
<th align="left">内存区域</th>
<th align="left">线程共享性</th>
<th align="left">作用</th>
<th align="left">可能发生的异常</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>程序计数器</strong> (Program Counter Register)</td>
<td align="left">线程私有</td>
<td align="left">存储当前线程执行的字节码指令地址</td>
<td align="left">无 (唯一不会发生 OOM 的区域)</td>
</tr>
<tr>
<td align="left"><strong>Java 虚拟机栈</strong> (Java Virtual Machine Stacks)</td>
<td align="left">线程私有</td>
<td align="left">存储栈帧，包含局部变量表、操作数栈、动态链接、方法返回地址</td>
<td align="left"><code>StackOverflowError</code>、<code>OutOfMemoryError</code></td>
</tr>
<tr>
<td align="left"><strong>本地方法栈</strong> (Native Method Stacks)</td>
<td align="left">线程私有</td>
<td align="left">为 Native 方法服务</td>
<td align="left"><code>StackOverflowError</code>、<code>OutOfMemoryError</code></td>
</tr>
<tr>
<td align="left"><strong>堆</strong> (Heap)</td>
<td align="left">线程共享</td>
<td align="left">存放对象实例和数组</td>
<td align="left"><code>OutOfMemoryError</code></td>
</tr>
<tr>
<td align="left"><strong>方法区</strong> (Method Area)</td>
<td align="left">线程共享</td>
<td align="left">存储类信息、常量、静态变量、即时编译器编译后的代码等</td>
<td align="left"><code>OutOfMemoryError</code></td>
</tr>
</tbody></table>
<h2 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h2><h3 id="1-程序计数器-Program-Counter-Register"><a href="#1-程序计数器-Program-Counter-Register" class="headerlink" title="1. 程序计数器 (Program Counter Register)"></a>1. 程序计数器 (Program Counter Register)</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令 [1]。</p>
<ul>
<li><strong>线程私有</strong>：为了保证线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器。</li>
<li><strong>唯一性</strong>：它是 JVM 运行时数据区中<strong>唯一一个不会出现 <code>OutOfMemoryError</code></strong> 的区域 [1]。</li>
</ul>
<h3 id="2-Java-虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#2-Java-虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="2. Java 虚拟机栈 (Java Virtual Machine Stacks)"></a>2. Java 虚拟机栈 (Java Virtual Machine Stacks)</h3><p>Java 虚拟机栈也是<strong>线程私有</strong>的，它的生命周期与线程相同。它描述的是 <strong>Java 方法执行的内存模型</strong>。每次方法调用都会伴随着一个<strong>栈帧</strong>（Stack Frame）的入栈和出栈 [1]。</p>
<p>每个栈帧包含以下核心组成部分：</p>
<ul>
<li><strong>局部变量表 (Local Variables Table)</strong>：存放方法参数和方法内部定义的局部变量，包括基本数据类型和对象引用（<code>reference</code> 类型）。</li>
<li><strong>操作数栈 (Operand Stack)</strong>：作为方法执行过程中进行计算的中转站，用于存放方法执行过程中产生的中间计算结果。</li>
<li><strong>动态链接 (Dynamic Linking)</strong>：将符号引用转换为直接引用的过程。对于虚方法，这个转换过程被推迟到程序运行期间，由动态链接完成，这是实现<strong>多态</strong>的基础。</li>
<li><strong>方法返回地址 (Return Address)</strong>：存放方法正常退出或异常退出的返回地址。</li>
</ul>
<p><strong>异常情况</strong>：</p>
<ul>
<li><strong><code>StackOverflowError</code></strong>：当线程请求的栈深度超过虚拟机允许的最大深度时抛出。</li>
<li><strong><code>OutOfMemoryError</code></strong>：如果虚拟机栈可以动态扩展，但在扩展时无法申请到足够的内存空间时抛出。</li>
</ul>
<h3 id="3-本地方法栈-Native-Method-Stacks"><a href="#3-本地方法栈-Native-Method-Stacks" class="headerlink" title="3. 本地方法栈 (Native Method Stacks)"></a>3. 本地方法栈 (Native Method Stacks)</h3><p>本地方法栈与虚拟机栈的作用相似，区别在于：<strong>虚拟机栈为执行 Java 方法服务，而本地方法栈则为执行 Native 方法服务</strong> [1]。在 HotSpot 虚拟机中，本地方法栈和 Java 虚拟机栈通常被合二为一。</p>
<h3 id="4-堆-Heap"><a href="#4-堆-Heap" class="headerlink" title="4. 堆 (Heap)"></a>4. 堆 (Heap)</h3><p>Java 堆是 JVM 所管理的内存中<strong>最大的一块</strong>，也是所有线程<strong>共享</strong>的一块内存区域。</p>
<ul>
<li><strong>核心作用</strong>：存放<strong>对象实例</strong>和<strong>数组</strong>。几乎所有的对象实例都在这里分配内存 [1]。</li>
<li><strong>垃圾回收</strong>：堆是垃圾收集器管理的主要区域，因此也被称为 <strong>GC 堆</strong>（Garbage Collected Heap）。</li>
<li><strong>分代思想</strong>：现代 JVM 普遍采用分代垃圾回收机制，因此堆内存通常被划分为<strong>新生代</strong>（Young Generation）和<strong>老年代</strong>（Old Generation）。新生代又细分为 <strong>Eden 区</strong>、<strong>From Survivor 区</strong>和 <strong>To Survivor 区</strong>。</li>
</ul>
<h3 id="5-方法区-Method-Area"><a href="#5-方法区-Method-Area" class="headerlink" title="5. 方法区 (Method Area)"></a>5. 方法区 (Method Area)</h3><p>方法区是所有线程<strong>共享</strong>的内存区域，它用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据 [1]。</p>
<ul>
<li><strong>演变</strong>：在 JDK 1.8 之前，HotSpot 虚拟机使用<strong>永久代</strong>（PermGen）来实现方法区。从 JDK 1.8 开始，永久代被彻底移除，取而代之的是<strong>元空间</strong>（Metaspace），元空间不再位于虚拟机内存中，而是使用<strong>本地内存</strong>（Native Memory） [1]。</li>
<li><strong>运行时常量池</strong>：方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</li>
<li><strong>字符串常量池</strong>：在 JDK 1.7 之后，字符串常量池从方法区（永久代）被移到了<strong>堆</strong>中 [1]。</li>
</ul>
<h3 id="6-直接内存-Direct-Memory"><a href="#6-直接内存-Direct-Memory" class="headerlink" title="6. 直接内存 (Direct Memory)"></a>6. 直接内存 (Direct Memory)</h3><p>直接内存<strong>不是</strong>JVM 运行时数据区的一部分，但它在 Java NIO 中被广泛使用。它通过 JNI 的方式在<strong>本地内存</strong>（Native Memory）中分配，不受 Java 堆大小的限制，但会受到本机总内存的限制 [1]。使用直接内存可以减少一次数据拷贝，提高性能。</p>
<h2 id="实践示例"><a href="#实践示例" class="headerlink" title="实践示例"></a>实践示例</h2><h3 id="Java-对象的创建过程"><a href="#Java-对象的创建过程" class="headerlink" title="Java 对象的创建过程"></a>Java 对象的创建过程</h3><p>当一个 Java 对象（如 <code>new Object()</code>）被创建时，JVM 会经历以下五个核心步骤 [1]：</p>
<table>
<thead>
<tr>
<th align="left">步骤</th>
<th align="left">描述</th>
<th align="left">发生区域</th>
<th align="left">关键操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Step 1: 类加载检查</strong></td>
<td align="left">检查类是否已被加载、解析和初始化。如果未加载，则执行相应的类加载过程。</td>
<td align="left">方法区</td>
<td align="left">验证、准备、解析、初始化</td>
</tr>
<tr>
<td align="left"><strong>Step 2: 分配内存</strong></td>
<td align="left">在堆上为对象实例分配所需的内存空间。分配方式包括<strong>指针碰撞</strong>（适用于内存规整）和<strong>空闲列表</strong>（适用于内存不规整）。</td>
<td align="left">堆</td>
<td align="left">内存分配</td>
</tr>
<tr>
<td align="left"><strong>Step 3: 初始化零值</strong></td>
<td align="left">将分配到的内存空间（不包括对象头）都初始化为零值（如 <code>int</code> 为 0，<code>boolean</code> 为 <code>false</code>）。</td>
<td align="left">堆</td>
<td align="left">保证对象的字段在Java代码中可以不赋初始值就直接使用</td>
</tr>
<tr>
<td align="left"><strong>Step 4: 设置对象头</strong></td>
<td align="left">设置对象头（Object Header），包括对象的哈希码、GC 分代年龄、锁状态标志、偏向线程 ID 等信息。</td>
<td align="left">堆</td>
<td align="left">记录对象的元数据信息</td>
</tr>
<tr>
<td align="left"><strong>Step 5: 执行 <code>&lt;init&gt;</code> 方法</strong></td>
<td align="left">执行 Java 程序的 <code>&lt;init&gt;</code> 方法（即构造函数），按照程序员的意愿对对象进行初始化。</td>
<td align="left">虚拟机栈</td>
<td align="left">真正完成对象初始化</td>
</tr>
</tbody></table>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java 程序通过栈上的 <strong>局部变量表</strong> 中的 <code>reference</code> 类型数据来操作堆上的具体对象。主流的访问方式有两种：</p>
<table>
<thead>
<tr>
<th align="left">访问方式</th>
<th align="left">描述</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>句柄访问</strong></td>
<td align="left">堆中会划分出一块内存作为<strong>句柄池</strong>。<code>reference</code> 存储的是对象的句柄地址，句柄中包含了对象实例数据和类型数据各自的地址。</td>
<td align="left"><code>reference</code> 中存储的是稳定的句柄地址，对象被移动（如垃圾回收时）时只需改变句柄中的实例数据指针，<code>reference</code> 本身无需修改。</td>
<td align="left">访问对象需要两次指针定位，效率略低。</td>
</tr>
<tr>
<td align="left"><strong>直接指针访问</strong></td>
<td align="left"><code>reference</code> 直接存储对象实例的地址。对象实例的内存中包含类型数据的指针。</td>
<td align="left">访问对象只需一次指针定位，速度更快。</td>
<td align="left">对象被移动时，<code>reference</code> 的值需要修改。</td>
</tr>
</tbody></table>
<p>HotSpot 虚拟机主要采用<strong>直接指针访问</strong>方式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JVM 运行时数据区是 Java 内存管理的核心，它将内存划分为<strong>线程私有</strong>（程序计数器、虚拟机栈、本地方法栈）和<strong>线程共享</strong>（堆、方法区）两大区域。其中，<strong>堆</strong>是最大且最活跃的区域，用于存放对象实例，是垃圾回收的主要场所；<strong>虚拟机栈</strong>则管理着方法的执行，通过栈帧实现方法的调用和局部变量的存储。理解这些区域的划分、作用及其生命周期，是进行 Java 性能优化和问题排查的基础。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://goppop.github.io">Goppop</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://goppop.github.io/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/">https://goppop.github.io/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://goppop.github.io" target="_blank">Goppop的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" title="JVM-垃圾回收机制详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JVM-垃圾回收机制详解</div></div><div class="info-2"><div class="info-item-1">JVM-垃圾回收机制详解概述垃圾回收（Garbage Collection, GC） 是 Java 虚拟机（JVM）自动管理内存的核心机制。它负责自动发现并释放不再被程序引用的对象所占用的内存空间，从而避免了手动内存管理带来的内存泄漏和内存溢出问题 [1]。 GC 的整个过程可以概括为两个核心步骤：  垃圾识别：判断哪些对象是“存活”的，哪些是“死亡”的（即不再被引用的）。 垃圾收集：回收死亡对象所占用的内存空间。  在垃圾回收过程中，为了确保数据的一致性，JVM 常常需要暂停所有应用线程，这个现象被称为 Stop-The-World (STW)。STW 的时间长短是衡量一个垃圾收集器性能的重要指标，现代 GC 优化的主要目标之一就是尽量缩短或消除 STW 时间 。 核心内容1. 垃圾对象的判断判断对象是否存活主要有两种算法： 1.1 引用计数法 (Reference Counting)为每个对象设置一个引用计数器，每当有一个地方引用它时，计数器加 1；当引用失效时，计数器减 1。计数器为 0 的对象即为垃圾。  优点：实现简单，判定效率高。 缺点：难以解决对象间的循环引用问题，...</div></div></div></a><a class="pagination-related" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%85%A5%E9%97%A8%E6%A6%82%E8%A7%88/" title="JVM-入门概览"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JVM-入门概览</div></div><div class="info-2"><div class="info-item-1">JVM-入门概览 作者：文档状态：  概述Java 虚拟机（JVM，Java Virtual Machine）是 Java 平台的核心组成部分，它是一种抽象的计算机，通过在实际的计算机上模拟各种计算机功能来实现。JVM 的主要职责是执行 Java 字节码（Bytecode），将 Java 语言的“一次编写，到处运行”（Write Once, Run Anywhere, WORA）的理念变为现实。 JVM 位于操作系统之上，为 Java 程序提供了一个统一的运行环境。无论是 Windows、Linux 还是 macOS，只要安装了对应的 JVM 实现，Java 程序就能无缝运行，这极大地提高了 Java 应用程序的跨平台能力和可移植性。对于 Java 开发者而言，深入理解 JVM 的工作原理是迈向高级开发和性能优化的必经之路。 核心内容JVM 的核心内容主要围绕其体系结构、运行时数据区、垃圾收集机制和类加载机制展开。 1. JVM 体系结构JVM 体系结构主要由以下几个部分组成：    组件 职责    类加载器 (Class Loader) 负责查找、加载和初始化 Java 类文...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%85%A5%E9%97%A8%E6%A6%82%E8%A7%88/" title="JVM-入门概览"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-12</div><div class="info-item-2">JVM-入门概览</div></div><div class="info-2"><div class="info-item-1">JVM-入门概览 作者：文档状态：  概述Java 虚拟机（JVM，Java Virtual Machine）是 Java 平台的核心组成部分，它是一种抽象的计算机，通过在实际的计算机上模拟各种计算机功能来实现。JVM 的主要职责是执行 Java 字节码（Bytecode），将 Java 语言的“一次编写，到处运行”（Write Once, Run Anywhere, WORA）的理念变为现实。 JVM 位于操作系统之上，为 Java 程序提供了一个统一的运行环境。无论是 Windows、Linux 还是 macOS，只要安装了对应的 JVM 实现，Java 程序就能无缝运行，这极大地提高了 Java 应用程序的跨平台能力和可移植性。对于 Java 开发者而言，深入理解 JVM 的工作原理是迈向高级开发和性能优化的必经之路。 核心内容JVM 的核心内容主要围绕其体系结构、运行时数据区、垃圾收集机制和类加载机制展开。 1. JVM 体系结构JVM 体系结构主要由以下几个部分组成：    组件 职责    类加载器 (Class Loader) 负责查找、加载和初始化 Java 类文...</div></div></div></a><a class="pagination-related" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" title="JVM-垃圾回收机制详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-12</div><div class="info-item-2">JVM-垃圾回收机制详解</div></div><div class="info-2"><div class="info-item-1">JVM-垃圾回收机制详解概述垃圾回收（Garbage Collection, GC） 是 Java 虚拟机（JVM）自动管理内存的核心机制。它负责自动发现并释放不再被程序引用的对象所占用的内存空间，从而避免了手动内存管理带来的内存泄漏和内存溢出问题 [1]。 GC 的整个过程可以概括为两个核心步骤：  垃圾识别：判断哪些对象是“存活”的，哪些是“死亡”的（即不再被引用的）。 垃圾收集：回收死亡对象所占用的内存空间。  在垃圾回收过程中，为了确保数据的一致性，JVM 常常需要暂停所有应用线程，这个现象被称为 Stop-The-World (STW)。STW 的时间长短是衡量一个垃圾收集器性能的重要指标，现代 GC 优化的主要目标之一就是尽量缩短或消除 STW 时间 。 核心内容1. 垃圾对象的判断判断对象是否存活主要有两种算法： 1.1 引用计数法 (Reference Counting)为每个对象设置一个引用计数器，每当有一个地方引用它时，计数器加 1；当引用失效时，计数器减 1。计数器为 0 的对象即为垃圾。  优点：实现简单，判定效率高。 缺点：难以解决对象间的循环引用问题，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Goppop</div><div class="author-info-description">周期越大，结构越清晰</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Goppop"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">JVM-内存模型详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9"><span class="toc-number">1.2.</span> <span class="toc-text">核心内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-Program-Counter-Register"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 程序计数器 (Program Counter Register)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-Java-Virtual-Machine-Stacks"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. Java 虚拟机栈 (Java Virtual Machine Stacks)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-Native-Method-Stacks"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 本地方法栈 (Native Method Stacks)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A0%86-Heap"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 堆 (Heap)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E5%8C%BA-Method-Area"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. 方法区 (Method Area)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98-Direct-Memory"><span class="toc-number">1.2.6.</span> <span class="toc-text">6. 直接内存 (Direct Memory)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">实践示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">Java 对象的创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.3.2.</span> <span class="toc-text">对象的访问定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E6%9C%AA%E5%88%86%E7%B1%BB/%E7%8C%9B%E6%94%BB/" title="无标题">无标题</a><time datetime="2025-12-15T07:20:32.924Z" title="发表于 2025-12-15 15:20:32">2025-12-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%85%A5%E9%97%A8%E6%A6%82%E8%A7%88/" title="JVM-入门概览">JVM-入门概览</a><time datetime="2025-12-11T16:00:00.000Z" title="发表于 2025-12-12 00:00:00">2025-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/" title="JVM-内存模型详解">JVM-内存模型详解</a><time datetime="2025-12-11T16:00:00.000Z" title="发表于 2025-12-12 00:00:00">2025-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" title="JVM-垃圾回收机制详解">JVM-垃圾回收机制详解</a><time datetime="2025-12-11T16:00:00.000Z" title="发表于 2025-12-12 00:00:00">2025-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/code-learning/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Spring%20Boot%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9AAOP%E3%80%81IOC%20%E4%B8%8E%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/" title="Spring Boot 核心原理与源码解析：AOP、IOC 与自动配置">Spring Boot 核心原理与源码解析：AOP、IOC 与自动配置</a><time datetime="2025-12-11T16:00:00.000Z" title="发表于 2025-12-12 00:00:00">2025-12-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Goppop</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3-b1"></script><script src="/js/main.js?v=5.5.3-b1"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>