<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM-垃圾回收机制详解 | Goppop的博客</title><meta name="author" content="Goppop"><meta name="copyright" content="Goppop"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM垃圾回收机制详解，深入理解GC算法和垃圾回收器">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM-垃圾回收机制详解">
<meta property="og:url" content="https://goppop.github.io/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Goppop的博客">
<meta property="og:description" content="JVM垃圾回收机制详解，深入理解GC算法和垃圾回收器">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://goppop.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-12-11T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-14T16:00:00.000Z">
<meta property="article:author" content="Goppop">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://goppop.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JVM-垃圾回收机制详解",
  "url": "https://goppop.github.io/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/",
  "image": "https://goppop.github.io/img/butterfly-icon.png",
  "datePublished": "2025-12-11T16:00:00.000Z",
  "dateModified": "2025-12-14T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Goppop",
      "url": "https://goppop.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://goppop.github.io/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM-垃圾回收机制详解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div id="web_bg" style="background-image: url(https://images.pexels.com/photos/1200252/pexels-photo-1200252.jpeg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.pixabay.com/photo/2021/03/29/08/22/peach-flower-6133330_1280.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Goppop的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">JVM-垃圾回收机制详解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">JVM-垃圾回收机制详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-11T16:00:00.000Z" title="发表于 2025-12-12 00:00:00">2025-12-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-14T16:00:00.000Z" title="更新于 2025-12-15 00:00:00">2025-12-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/code-learning/">代码开发学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/code-learning/programming-basics/">01-编程语言基础</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/code-learning/programming-basics/jvm/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="JVM-垃圾回收机制详解"><a href="#JVM-垃圾回收机制详解" class="headerlink" title="JVM-垃圾回收机制详解"></a>JVM-垃圾回收机制详解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>垃圾回收（Garbage Collection, GC）</strong> 是 Java 虚拟机（JVM）自动管理内存的核心机制。它负责自动发现并释放不再被程序引用的对象所占用的内存空间，从而避免了手动内存管理带来的内存泄漏和内存溢出问题 [1]。</p>
<p>GC 的整个过程可以概括为两个核心步骤：</p>
<ol>
<li><strong>垃圾识别</strong>：判断哪些对象是“存活”的，哪些是“死亡”的（即不再被引用的）。</li>
<li><strong>垃圾收集</strong>：回收死亡对象所占用的内存空间。</li>
</ol>
<p>在垃圾回收过程中，为了确保数据的一致性，JVM 常常需要暂停所有应用线程，这个现象被称为 <strong>Stop-The-World (STW)</strong>。STW 的时间长短是衡量一个垃圾收集器性能的重要指标，现代 GC 优化的主要目标之一就是尽量缩短或消除 STW 时间 。</p>
<h2 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h2><h3 id="1-垃圾对象的判断"><a href="#1-垃圾对象的判断" class="headerlink" title="1. 垃圾对象的判断"></a>1. 垃圾对象的判断</h3><p>判断对象是否存活主要有两种算法：</p>
<h4 id="1-1-引用计数法-Reference-Counting"><a href="#1-1-引用计数法-Reference-Counting" class="headerlink" title="1.1 引用计数法 (Reference Counting)"></a>1.1 引用计数法 (Reference Counting)</h4><p>为每个对象设置一个引用计数器，每当有一个地方引用它时，计数器加 1；当引用失效时，计数器减 1。计数器为 0 的对象即为垃圾。</p>
<ul>
<li><strong>优点</strong>：实现简单，判定效率高。</li>
<li><strong>缺点</strong>：难以解决<strong>对象间的循环引用</strong>问题，因此主流的 JVM（如 HotSpot）并没有采用此算法 。</li>
</ul>
<h4 id="1-2-可达性分析算法-Reachability-Analysis"><a href="#1-2-可达性分析算法-Reachability-Analysis" class="headerlink" title="1.2 可达性分析算法 (Reachability Analysis)"></a>1.2 可达性分析算法 (Reachability Analysis)</h4><p>该算法通过一系列被称为 <strong>GC Roots</strong> 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的，可以被回收 。</p>
<p><strong>可作为 GC Roots 的对象包括</strong> [1]：</p>
<ul>
<li>虚拟机栈（栈帧中的局部变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中 JNI（Native 方法）引用的对象。</li>
</ul>
<h3 id="2-对象的四种引用类型"><a href="#2-对象的四种引用类型" class="headerlink" title="2. 对象的四种引用类型"></a>2. 对象的四种引用类型</h3><p>Java 提供了四种引用类型，强度依次递减，用于更灵活地控制对象的生命周期 [1]：</p>
<table>
<thead>
<tr>
<th align="left">引用类型</th>
<th align="left">强度</th>
<th align="left">GC 行为</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>强引用</strong> (Strong)</td>
<td align="left">最强</td>
<td align="left">只要强引用存在，垃圾回收器永远不会回收被引用的对象。</td>
<td align="left">普遍使用的引用类型。</td>
</tr>
<tr>
<td align="left"><strong>软引用</strong> (Soft)</td>
<td align="left">较强</td>
<td align="left">内存空间足够时不会回收；在即将发生内存溢出前，会回收软引用对象。</td>
<td align="left">用于实现内存敏感的高速缓存。</td>
</tr>
<tr>
<td align="left"><strong>弱引用</strong> (Weak)</td>
<td align="left">较弱</td>
<td align="left">只要发生 GC，无论内存是否充足，都会回收被弱引用关联的对象。</td>
<td align="left">用于实现生命周期较短的缓存，如 <code>WeakHashMap</code>。</td>
</tr>
<tr>
<td align="left"><strong>虚引用</strong> (Phantom)</td>
<td align="left">最弱</td>
<td align="left">无法通过虚引用获取对象实例。唯一目的是在对象被回收时收到一个系统通知。</td>
<td align="left">用于跟踪对象被回收的状态，配合 <code>ReferenceQueue</code> 使用。</td>
</tr>
</tbody></table>
<h3 id="3-分代收集理论-Generational-Collection"><a href="#3-分代收集理论-Generational-Collection" class="headerlink" title="3. 分代收集理论 (Generational Collection)"></a>3. 分代收集理论 (Generational Collection)</h3><p>现代 JVM 普遍采用分代收集理论，将 Java 堆划分为<strong>新生代</strong>（Young Generation）和<strong>老年代</strong>（Old Generation），并根据各自的特点采用不同的 GC 策略 [1]。</p>
<table>
<thead>
<tr>
<th align="left">区域</th>
<th align="left">特点</th>
<th align="left">GC 频率</th>
<th align="left">采用算法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>新生代</strong></td>
<td align="left">绝大多数对象生命周期短，朝生夕死。</td>
<td align="left">频繁（Minor GC）</td>
<td align="left">复制算法（Copying）</td>
</tr>
<tr>
<td align="left"><strong>老年代</strong></td>
<td align="left">存放长期存活的对象，对象存活率高。</td>
<td align="left">较低（Major GC）</td>
<td align="left">标记-整理（Mark-Compact）或标记-清除（Mark-Sweep）及其变种</td>
</tr>
</tbody></table>
<p><strong>GC 类型划分</strong> [1]：</p>
<ul>
<li><strong>Minor GC &#x2F; Young GC</strong>：发生在新生代的垃圾收集。速度快，STW 短。</li>
<li><strong>Major GC &#x2F; Old GC</strong>：发生在老年代的垃圾收集。通常比 Minor GC 慢 10 倍以上。</li>
<li><strong>Full GC</strong>：收集整个 Java 堆和方法区。是所有 GC 中最慢的，应尽量避免。</li>
</ul>
<h3 id="4-垃圾收集算法"><a href="#4-垃圾收集算法" class="headerlink" title="4. 垃圾收集算法"></a>4. 垃圾收集算法</h3><table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">描述</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>标记-清除</strong> (Mark-Sweep)</td>
<td align="left">先标记出所有可回收对象，然后统一回收被标记的对象。</td>
<td align="left">实现简单。</td>
<td align="left">产生大量不连续的<strong>内存碎片</strong>。</td>
<td align="left">老年代（配合压缩）</td>
</tr>
<tr>
<td align="left"><strong>复制</strong> (Copying)</td>
<td align="left">将内存划分为大小相等的两块，每次只使用其中一块。当这块用完后，将存活对象复制到另一块上，然后清空已使用的这块。</td>
<td align="left">不产生内存碎片，效率高。</td>
<td align="left">内存利用率低（仅 50%）。</td>
<td align="left">新生代（Eden:Survivor&#x3D;8:1:1，空间浪费小）</td>
</tr>
<tr>
<td align="left"><strong>标记-整理</strong> (Mark-Compact)</td>
<td align="left">先标记存活对象，然后将所有存活对象移动到内存的一端，最后清理掉边界以外的内存。</td>
<td align="left">不产生内存碎片。</td>
<td align="left">效率相对较低，需要移动对象。</td>
<td align="left">老年代</td>
</tr>
</tbody></table>
<h3 id="5-经典垃圾收集器"><a href="#5-经典垃圾收集器" class="headerlink" title="5. 经典垃圾收集器"></a>5. 经典垃圾收集器</h3><p>JVM 提供了多种垃圾收集器，它们是上述算法的具体实现。在 JDK 9 之后，默认的垃圾收集器是 <strong>G1</strong> [1]。</p>
<table>
<thead>
<tr>
<th align="left">收集器</th>
<th align="left">作用区域</th>
<th align="left">算法</th>
<th align="left">特点</th>
<th align="left">目标</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Serial</strong></td>
<td align="left">新生代</td>
<td align="left">复制</td>
<td align="left">单线程，STW 长。</td>
<td align="left">客户端模式下默认新生代收集器。</td>
</tr>
<tr>
<td align="left"><strong>ParNew</strong></td>
<td align="left">新生代</td>
<td align="left">复制</td>
<td align="left">Serial 的多线程版本，多核 CPU 下效率高。</td>
<td align="left">配合 CMS 使用。</td>
</tr>
<tr>
<td align="left"><strong>Parallel Scavenge</strong></td>
<td align="left">新生代</td>
<td align="left">复制</td>
<td align="left">多线程，关注<strong>吞吐量</strong>（Throughput）。</td>
<td align="left">适合后台运算，对 STW 不敏感的场景。</td>
</tr>
<tr>
<td align="left"><strong>Serial Old</strong></td>
<td align="left">老年代</td>
<td align="left">标记-整理</td>
<td align="left">Serial 的老年代版本，单线程。</td>
<td align="left">客户端模式下默认老年代收集器，或作为 CMS 失败时的后备。</td>
</tr>
<tr>
<td align="left"><strong>Parallel Old</strong></td>
<td align="left">老年代</td>
<td align="left">标记-整理</td>
<td align="left">Parallel Scavenge 的老年代版本，多线程。</td>
<td align="left">配合 Parallel Scavenge 关注吞吐量。</td>
</tr>
<tr>
<td align="left"><strong>CMS</strong></td>
<td align="left">老年代</td>
<td align="left">标记-清除</td>
<td align="left"><strong>并发</strong>收集，以获取<strong>最短回收停顿时间</strong>为目标。</td>
<td align="left">适用于对响应时间要求高的 Web 应用。</td>
</tr>
<tr>
<td align="left"><strong>G1</strong></td>
<td align="left">整个堆</td>
<td align="left">标记-整理 + 复制</td>
<td align="left"><strong>分区</strong>（Region）化管理，可预测的停顿时间。</td>
<td align="left">适用于大内存（6GB 以上），追求低延迟的场景。</td>
</tr>
<tr>
<td align="left"><strong>ZGC&#x2F;Shenandoah</strong></td>
<td align="left">整个堆</td>
<td align="left">标记-整理</td>
<td align="left"><strong>并发</strong>收集，<strong>停顿时间极短</strong>（10ms 以内）。</td>
<td align="left">适用于对延迟要求极高的场景。</td>
</tr>
</tbody></table>
<h2 id="实践示例"><a href="#实践示例" class="headerlink" title="实践示例"></a>实践示例</h2><h3 id="内存分配原则"><a href="#内存分配原则" class="headerlink" title="内存分配原则"></a>内存分配原则</h3><p>JVM 内存分配遵循以下几个基本原则，这些原则是分代收集理论的具体体现 [1]：</p>
<ol>
<li><strong>对象优先在 Eden 区分配</strong>：大多数对象在新生代的 Eden 区分配。当 Eden 区空间不足时，会触发 Minor GC。</li>
<li><strong>大对象直接进入老年代</strong>：需要大量连续内存空间的对象（如大数组）会直接在老年代分配，以避免在新生代频繁进行 Minor GC 带来的额外开销。</li>
<li><strong>长期存活的对象将进入老年代</strong>：JVM 为每个对象定义了年龄计数器。对象在新生代每经历一次 Minor GC 仍存活，年龄就加 1。当年龄达到一定阈值（默认为 15，CMS 默认为 6，可通过 <code>-XX:MaxTenuringThreshold</code> 设置）时，对象会被晋升到老年代。</li>
<li><strong>空间分配担保</strong>：在发生 Minor GC 之前，JVM 会检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果大于，则 Minor GC 是安全的；如果小于，则会查看是否允许担保失败。如果允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小。如果大于，则尝试进行 Minor GC；否则，将进行 Full GC。</li>
</ol>
<h3 id="常用-GC-参数"><a href="#常用-GC-参数" class="headerlink" title="常用 GC 参数"></a>常用 GC 参数</h3><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-Xms</code></td>
<td align="left">初始堆大小</td>
<td align="left"><code>-Xms512m</code></td>
</tr>
<tr>
<td align="left"><code>-Xmx</code></td>
<td align="left">最大堆大小</td>
<td align="left"><code>-Xmx1024m</code></td>
</tr>
<tr>
<td align="left"><code>-XX:+UseSerialGC</code></td>
<td align="left">启用 Serial + Serial Old 收集器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>-XX:+UseParNewGC</code></td>
<td align="left">启用 ParNew + Serial Old 收集器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>-XX:+UseParallelGC</code></td>
<td align="left">启用 Parallel Scavenge + Parallel Old 收集器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>-XX:+UseConcMarkSweepGC</code></td>
<td align="left">启用 CMS 收集器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>-XX:+UseG1GC</code></td>
<td align="left">启用 G1 收集器（JDK 9+ 默认）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>-XX:MaxGCPauseMillis</code></td>
<td align="left">设置最大 GC 停顿时间（G1、Parallel Scavenge 等）</td>
<td align="left"><code>-XX:MaxGCPauseMillis=200</code></td>
</tr>
<tr>
<td align="left"><code>-XX:+PrintGCDetails</code></td>
<td align="left">打印详细的 GC 日志</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>-XX:NewRatio=N</code></td>
<td align="left">老年代 : 新生代 &#x3D; N : 1</td>
<td align="left"><strong>若设置 <code>-Xmn</code>，此参数失效</strong></td>
</tr>
<tr>
<td align="left"><code>-XX:SurvivorRatio=R</code></td>
<td align="left">Eden : 一个 Survivor &#x3D; R : 1</td>
<td align="left">控制新生代内部比例</td>
</tr>
<tr>
<td align="left"><code>-XX:MaxMetaspaceSize</code></td>
<td align="left">限制元空间最大内存</td>
<td align="left">防止因动态类加载（如反射、CGLib）导致内存溢出</td>
</tr>
</tbody></table>
<blockquote>
<p>计算关系：</p>
<p>老年代大小 &#x3D; <code>-Xmx</code> - <code>-Xmn</code></p>
</blockquote>
<h2 id="关于-Full-GC-的关键认知"><a href="#关于-Full-GC-的关键认知" class="headerlink" title="关于 Full GC 的关键认知"></a>关于 Full GC 的关键认知</h2><ul>
<li><strong>Parallel GC 无法避免 Full GC</strong>：老年代满即触发，停顿时间与老年代大小正相关。</li>
<li><strong>G1 GC 可大幅降低 Full GC 频率</strong>：通过 Mixed GC 并发回收老年代区域。</li>
<li><strong>ZGC &#x2F; Shenandoah 可基本消除 Full GC</strong>：停顿时间 &lt;10ms，适合低延迟场景。</li>
</ul>
<blockquote>
<p>若业务对停顿敏感（如实时系统、高频服务），应优先考虑 G1（JDK8u40+）或 ZGC（JDK11+），而非调优 Parallel GC。</p>
</blockquote>
<h2 id="常见误区纠正"><a href="#常见误区纠正" class="headerlink" title="常见误区纠正"></a>常见误区纠正</h2><table>
<thead>
<tr>
<th>误区</th>
<th>正确认知</th>
</tr>
</thead>
<tbody><tr>
<td>“SurvivorRatio 越小，Eden 越大”</td>
<td><strong>SurvivorRatio 越大，Eden 占比越高</strong></td>
</tr>
<tr>
<td>“内存设大就不需要调优”</td>
<td>大堆可能导致 Full GC 停顿更长，风险更高</td>
</tr>
<tr>
<td>“NewRatio 总是生效”</td>
<td>若显式设置 <code>-Xmn</code>，NewRatio 被忽略</td>
</tr>
<tr>
<td>“关闭 UseAdaptiveSizePolicy 不重要”</td>
<td>Parallel GC 默认开启自适应策略，会覆盖手动 Ratio 设置</td>
</tr>
</tbody></table>
<hr>
<h2 id="调优基本原则"><a href="#调优基本原则" class="headerlink" title="调优基本原则"></a>调优基本原则</h2><ol>
<li><strong>明确目标</strong>：是优化吞吐量，还是降低停顿时间？</li>
<li><strong>控制新生代大小</strong>：通过 <code>Xmn</code> 精确管理老年代容量。</li>
<li><strong>合理设置比例</strong>：根据对象生命周期调整 <code>SurvivorRatio</code> 和晋升阈值。</li>
<li><strong>关闭自适应策略</strong>：确保手动配置生效。</li>
<li><strong>持续监控</strong>：通过 GC 日志和工具（如 <code>jstat</code>）观察实际行为。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>JVM 调优的核心不是追求“零 GC”，而是<strong>确保 GC 行为符合业务 SLO</strong>。</p>
<p>通过合理配置内存结构与 GC 策略，可在资源约束下实现稳定、高效的运行时表现。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://goppop.github.io">Goppop</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://goppop.github.io/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">https://goppop.github.io/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://goppop.github.io" target="_blank">Goppop的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/" title="JVM-内存模型详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JVM-内存模型详解</div></div><div class="info-2"><div class="info-item-1">JVM-内存模型详解概述Java 虚拟机（JVM）内存模型，更准确地说是 JVM 运行时数据区（Runtime Data Areas），是Java虚拟机在执行Java程序过程中，将其管理的内存划分为若干个不同的数据区域。理解这些区域对于深入掌握Java程序的运行机制、内存分配、垃圾回收以及进行性能调优和故障排查至关重要 。 需要注意的是，JVM 运行时数据区（JVM Runtime Data Areas）与 Java 内存模型（Java Memory Model, JMM）是两个不同的概念。JVM 运行时数据区关注的是JVM如何划分和管理内存，而 JMM 则关注于在多线程环境下，变量在内存中的可见性、有序性和原子性等问题。本文档主要聚焦于前者，即 JVM 运行时数据区。 JVM 运行时数据区主要包含以下五个部分，它们根据是否被线程共享可以分为两大类：    内存区域 线程共享性 作用 可能发生的异常    程序计数器 (Program Counter Register) 线程私有 存储当前线程执行的字节码指令地址 无 (唯一不会发生 OOM 的区域)   Java 虚拟机栈 (J...</div></div></div></a><a class="pagination-related" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%85%A5%E9%97%A8%E6%A6%82%E8%A7%88/" title="JVM-入门概览"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JVM-入门概览</div></div><div class="info-2"><div class="info-item-1">JVM-入门概览 作者：文档状态：  概述Java 虚拟机（JVM，Java Virtual Machine）是 Java 平台的核心组成部分，它是一种抽象的计算机，通过在实际的计算机上模拟各种计算机功能来实现。JVM 的主要职责是执行 Java 字节码（Bytecode），将 Java 语言的“一次编写，到处运行”（Write Once, Run Anywhere, WORA）的理念变为现实。 JVM 位于操作系统之上，为 Java 程序提供了一个统一的运行环境。无论是 Windows、Linux 还是 macOS，只要安装了对应的 JVM 实现，Java 程序就能无缝运行，这极大地提高了 Java 应用程序的跨平台能力和可移植性。对于 Java 开发者而言，深入理解 JVM 的工作原理是迈向高级开发和性能优化的必经之路。 核心内容JVM 的核心内容主要围绕其体系结构、运行时数据区、垃圾收集机制和类加载机制展开。 1. JVM 体系结构JVM 体系结构主要由以下几个部分组成：    组件 职责    类加载器 (Class Loader) 负责查找、加载和初始化 Java 类文...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%85%A5%E9%97%A8%E6%A6%82%E8%A7%88/" title="JVM-入门概览"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-12</div><div class="info-item-2">JVM-入门概览</div></div><div class="info-2"><div class="info-item-1">JVM-入门概览 作者：文档状态：  概述Java 虚拟机（JVM，Java Virtual Machine）是 Java 平台的核心组成部分，它是一种抽象的计算机，通过在实际的计算机上模拟各种计算机功能来实现。JVM 的主要职责是执行 Java 字节码（Bytecode），将 Java 语言的“一次编写，到处运行”（Write Once, Run Anywhere, WORA）的理念变为现实。 JVM 位于操作系统之上，为 Java 程序提供了一个统一的运行环境。无论是 Windows、Linux 还是 macOS，只要安装了对应的 JVM 实现，Java 程序就能无缝运行，这极大地提高了 Java 应用程序的跨平台能力和可移植性。对于 Java 开发者而言，深入理解 JVM 的工作原理是迈向高级开发和性能优化的必经之路。 核心内容JVM 的核心内容主要围绕其体系结构、运行时数据区、垃圾收集机制和类加载机制展开。 1. JVM 体系结构JVM 体系结构主要由以下几个部分组成：    组件 职责    类加载器 (Class Loader) 负责查找、加载和初始化 Java 类文...</div></div></div></a><a class="pagination-related" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/" title="JVM-内存模型详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-12</div><div class="info-item-2">JVM-内存模型详解</div></div><div class="info-2"><div class="info-item-1">JVM-内存模型详解概述Java 虚拟机（JVM）内存模型，更准确地说是 JVM 运行时数据区（Runtime Data Areas），是Java虚拟机在执行Java程序过程中，将其管理的内存划分为若干个不同的数据区域。理解这些区域对于深入掌握Java程序的运行机制、内存分配、垃圾回收以及进行性能调优和故障排查至关重要 。 需要注意的是，JVM 运行时数据区（JVM Runtime Data Areas）与 Java 内存模型（Java Memory Model, JMM）是两个不同的概念。JVM 运行时数据区关注的是JVM如何划分和管理内存，而 JMM 则关注于在多线程环境下，变量在内存中的可见性、有序性和原子性等问题。本文档主要聚焦于前者，即 JVM 运行时数据区。 JVM 运行时数据区主要包含以下五个部分，它们根据是否被线程共享可以分为两大类：    内存区域 线程共享性 作用 可能发生的异常    程序计数器 (Program Counter Register) 线程私有 存储当前线程执行的字节码指令地址 无 (唯一不会发生 OOM 的区域)   Java 虚拟机栈 (J...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Goppop</div><div class="author-info-description">周期越大，结构越清晰</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Goppop"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">JVM-垃圾回收机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9"><span class="toc-number">1.2.</span> <span class="toc-text">核心内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9E%83%E5%9C%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 垃圾对象的判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95-Reference-Counting"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.1 引用计数法 (Reference Counting)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95-Reachability-Analysis"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">1.2 可达性分析算法 (Reachability Analysis)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 对象的四种引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA-Generational-Collection"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 分代收集理论 (Generational Collection)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 垃圾收集算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. 经典垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">实践示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.1.</span> <span class="toc-text">内存分配原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-GC-%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">常用 GC 参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-Full-GC-%E7%9A%84%E5%85%B3%E9%94%AE%E8%AE%A4%E7%9F%A5"><span class="toc-number">1.4.</span> <span class="toc-text">关于 Full GC 的关键认知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA%E7%BA%A0%E6%AD%A3"><span class="toc-number">1.5.</span> <span class="toc-text">常见误区纠正</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">1.6.</span> <span class="toc-text">调优基本原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/trading-log/%E4%BA%A4%E6%98%93/%E4%BA%A4%E6%98%93%E8%AE%B0%E5%BD%95%EF%BC%9AETH%20%E5%90%88%E7%BA%A6%E5%A4%9A%E5%8D%95/" title="交易记录">交易记录</a><time datetime="2025-12-21T16:00:00.000Z" title="发表于 2025-12-22 00:00:00">2025-12-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/code-learning/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88JUC%EF%BC%89%E9%AB%98%E7%BA%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%8E%9F%E7%90%86%EF%BC%9A%E4%BB%8E%20AQS%20%E5%88%B0%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%20(1)/" title="Java 并发编程（JUC）高级组件与原理：从 AQS 到并发容器">Java 并发编程（JUC）高级组件与原理：从 AQS 到并发容器</a><time datetime="2025-12-16T16:00:00.000Z" title="发表于 2025-12-17 00:00:00">2025-12-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/code-learning/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Spring%20Boot%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9AAOP%E3%80%81IOC%20%E4%B8%8E%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/" title="Spring Boot 核心原理与源码解析：AOP、IOC 与自动配置">Spring Boot 核心原理与源码解析：AOP、IOC 与自动配置</a><time datetime="2025-12-16T16:00:00.000Z" title="发表于 2025-12-17 00:00:00">2025-12-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%85%A5%E9%97%A8%E6%A6%82%E8%A7%88/" title="JVM-入门概览">JVM-入门概览</a><time datetime="2025-12-11T16:00:00.000Z" title="发表于 2025-12-12 00:00:00">2025-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/code-learning/programming-basics/jvm/%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" title="JVM-垃圾回收机制详解">JVM-垃圾回收机制详解</a><time datetime="2025-12-11T16:00:00.000Z" title="发表于 2025-12-12 00:00:00">2025-12-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Goppop</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3-b1"></script><script src="/js/main.js?v=5.5.3-b1"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>